Лекция 01: Подготовка
Для создания мода потребуются три приложения:
1. Visual studio: 
2. Notepad++: 
3. ILSpy:


------
------
Лекция 02: Состав мода. События 

Мод состоит из 7 основных папок:
About - содержит информацию о моде
Assemblies - содержит доп библиотеки 
Defs - содержит объекты
Languages - содержит переводы
Patches - патчи
Source - звуки
Textures - текстуры

About содержит
PublishedFileId.txt - содержит ид мода в стим
About.xml - информация о моде
Preview.png - картинка для отображения 640x400

Assemblies 
Содержит dll библиотеки. Порядок загрузки важен. Начинаем название с цифр (0,1,2)

Defs (предметы, строения)
Можно создавать любое кол-во папок и название внутри с любой вложенностью. Для игры они все будит хранится в Defs.

Languages 
Содержит языки. Название языка такое же, как и в ядре.
Содержит две основных папки DefInjected (для полей предмета) и Keyed (ключ-значения для событий и информации).
В DefInjected создаются папки наименования которой соответствуют классу предметов (обязательно).

Patches
Позволяют манипулировать значением дефов не на уровне кода. Например изменить категорию


---

Игровые события:
1) Инциденты - происходят по щелчку, случайно (взрыв, рейд)
2) Игровые условия - являются активными определённое время (радиация)

---

Подготовка Visual Studio:
1) В VS выбираем: Библиотека классов (.NET Framefork)

2) В настройках проекта (Properties) изменяем платформу:
Платформу выбираем Net Framfork 3.5 Client Profile для версии игры 1.1
Платформу выбираем Net Framfork 4.8 Client Profile для версии игры 1.3 

3) Добавляем библиотеки в ссылки:
Ссылки--> Добавить ссылку. --> Обзор
Через обзор находим игру и папку RimWorldWin64_Data/Managed в ней.
Потребуются Assembly-CSharp.dll (содержит исходный код игры) и UnityEngine.dll (содержит вектора и значения)
Для удобства скопируем эти библиотеки в папку с проектами (Libs)
Добавим библиотеки в студии

4) Откроем библиотеки в ILSpy 
Через поиск можно находить нужные объекты игры в библиотеки и проследить корень вызовов и узнать доступные методы и требующиеся к ним параметры.

При создании классов следует по возможности руководствовать правилом именования разработчиков игры. Перед названием класс указываем его принадлежность (Если это событие - Инцидент, если настройки - Кондишен и  т.д.)
ПРИМЕР: IncidentWorker_TestIncident.cs
Класс с нашим инцидентом должен наследоваться от класс IncidentWorker
Находим класс IncidentWorker через ILSpy

Важные связанные параметры:
IncidentDef def; - содержит деф событие (описание) для создания дефа
float AdjustedChance - содержит шанс события (по умолчанию равно базовому шансу)
bool CanFireNowSub - проверка на разрешение вызова события

У всех инцидентов есть таргет. Все таргеты можно посмотреть в IncidentTargetDef и IncidentTargetDefOf
World - распространяется на весь мир
Caravan - распространяется на ваш караван
Map_RaidBecon - локальное, когда драка караваном
Map_PlayerHome - локальное на карте игрока
Map_Misc - локальное на все остальные карты

IncidentParms - генерируется рассказчиком, содержит параметры


Для игрового события переопределяем два основных метода
CanFireNowSub(вызывается рассказчиком) и TryExecuteWorker (вызывается через геймМод)

Редактирование параметров объекта (DEF) через файл .xml
В папке Core находим нужный Defs для нашего события. События находятся в папке Storyteller копируем нужный инцидент из Core в папку Defs нашего мода и открываем через нотпад.

Удаляем все инцидента кроме одного который будим редактировать (самый последний, самый удобный)
defName - уникальный идентификатор события (не может заканчивается на цифры)
label - отображаемое название
category - доступные категории содержатся в классе IncidentCategoryDef (оставим Misc)
allowedBiomes - выбираем биомы (список) где будит происходить событие
targetTags - выбираем где будит происходить событие (например на карте игрока Map_PlayerHome)
Установка настроек, когда может произойти событие
baseChance - шанс вызова события от 0 до 100
earliestDay - минимальное количество дней между повтором события

Что бы привязать наш класс к инциденту нужно указать его workerClass. Указываем в нем имя созданного нами класса. Имя копируется полностью вместе с namespace

В Visual Studio уберем для библиотек локальное копирование, что бы она не помещалась в скомпилированный мод.
Свойства-->Библиотека-->Настройка-->Копировать локально--> false

Соберём библиотеку и копируем в папку Assemblies нашего мода. Можно осуществить проверку мода в игре.

Когда нам требуется вызвать уведомление о событии добавляем
SendStandardLetter();

Что бы информация о событии отразилась корректно необходимо исправить xml файл добавив поля для описания (можно скопировать из другого события)
		<letterLabel>Текст с названием</letterLabel>
		<letterText>Описание события в рамке события</letterText>
		<letterDef>PositiveEvent</letterDef> /**тип сообщения цвет и звук/

ПЕРОВОД для МОДОВ
После создание объекта создадим для него перевод:
В папке DefInjected создаем папку IncidentDef. Это название совпадает с базовым классом события. Для удобства шаблон скачаем из соответствующе папки в core


----


Создадим событие с условием (будит длится некоторое время)
Определим новый класс
GameCondition_TestCondition : GameCondition
Содержит:
GameConditionManager gameConditionManager; - управления событиями для карты 
duration  - длительность
и.т.д
Основные методы:
Init() - определяет что будит в начале события
GameConditionTick() что будит происходить каждый тик
End() что произойдёт по окончанию события


После создания класса и сборки новой библиотеки, необходимо создать Def для условия Incidents_World_Conditions. шаблон можно скопировать из Core 
Указываем имя и описание, задаем нужные параметры
Для  <gameCondition>TestGameCondition</gameCondition> можно задать отдельные настройки. 
Также копируем из ядра GameConditions_Misc.xml
Для того что бы связать условие необходимо GameConditions_Misc.xml связать с классом 	<conditionClass>LearningModBuildings.EventMod.Events.GameCondition_TestCondition</conditionClass>




------
------

Лекция 03: HediffDef. Атрибут DefOf, Сложный перевод.

Состояние пешки (здоровье, протезы)
Состояния хранятся в Hediffs_Global_Misc.xml
Класс в dll - HediffDef

Основные поля XML:
lethalSeverity - прогресс болезни (указывается предельное значения для достижения смерти)
initialSeverity - начальное состояние болезни
tendable (может ли быть перевязана)
comps -  дополняет компоненты к болезни (отображает эффекты когда перевязано, сколько держится, какой эффект и т.д.)



Поля класса соответствуют:
public List<HediffStage> stages; - Список стадий течения болезни 
public bool isBad = true; - Является ли болезнь плохой (опьянение)
public ThingDef spawnThingOnRemoved; - Что появится если будет удален, например вернется протез



СЛОЖНЫЕ ПЕРЕВОДЫ
Некоторые поля не имеют своего ключа. Например, Hediffs_Global_Misc для лейблов стадий болезни используются списки, получить ключ эл-та списка затруднительно.
Для этого в методе по умолчанию наименование поле переименовано в значение вложенного текста, чтобы осуществить перевод используют имена, указанные в лейбле
public void PostLoad()
{
	this.untranslatedLabel = this.label;
}
 <label>middle</label> <TestHeddiff.stages.middle-0.lavel>Стадия</TestHeddiff.stages.middle-0.lavel>
!! Пробелы заменяются на нижние подчёркивания



----
----

Лекция 04: [#4] Создание модов для RimWorld - Шаг 4 - ThingDef. Things. Основы.


ThingDef - Базовый класс строений и вещей в игре.
Все действия в игре привязаны к тикам. Каждый тик происходит какое-то действие. Опрашиваются предметы, читаются таймеры.

Предметы имеют четыре вида тиков:
Невер - никогда не участвует
Нормал - Стандартный
Рере - 250 тиков 
Лонг - 2000 тиков
Тип тикера указывается в поле TikerType. Нужен для оптимизации. Если состояние предмета должно проверятся раз в игровые сутки следует использовать тип лонг.

В тег <graphicData> помещается текстура дефа. Можно задать цвет, размер, 
Путь к текстуре начинается из папки Things которая должна быть в папке Textures:
<texPath>Things/sfera</texPath> 

<graphicClass>Graphic_Single</graphicClass> - позволяет добавить дополнительный обработчик текстуры (Graphic_Single - стандартная, то есть не меняется)
<drawSize>(1,2)</drawSize> - размер предмета
<size>(3, 3)</size> физический размер предмета - может не совпадать с drawSize

В списке comps указываются возможности предмета, вырабатывает/потребляет электричество, выключается, светится и т.д.
Класс действия можно указать стандартно записью в виде тега или указать как пармерт тега li:
<li Class="CompProperties_Power">

----
----
Building наследуется от Things - отвечает за строения

метод SpawnSetup - вызывается при спавне предмета
метод Tick() - вызывается при тике

Метод public override IEnumerable<FloatMenuOption> GetFloatMenuOptions(Pawn selPawn) позволяет создать меню взаимодействия с предметом     
Метод   private FloatMenuOption GetOption() - позволяет добавить еще опцию в меню

Gizmo - Это выпадающие кнопки снизу предмета добавляются через метод public override IEnumerable<Gizmo> GetGizmos()

----

Реализация компонентов предмета - comps

Компонент реализуется двумя классами CompProperties который указывается в xml и класс обработчик.
При создании свойст компа класс наследуется от CompProperties
public class CompProperties_MyTestBilding : CompProperties
В конструкторе класса поле compClass может быть заполонено классом, наследуемым от ThingComp который определить нужное свойства
Можно создать свой класс со своим действием
public class CompMyTestBuilding : ThingComp

Теперь свой компс можно добавить список xml:
<li Class=" LearningModBuildings.HediffMod.Bildings.CompProperties_MyTestBilding">	
	<Damage>500</Damage>
</li>

Для вызова компонента в класс (Building_MyTestBilding : Building) следует добавить поле
private CompMyTestBuilding compMyTestBuilding;
После чего в методе при спавне предмета (SpawnSetup) добавить его инициализацию:
compMyTestBuilding = this.GetComp<CompMyTestBuilding>(); //получение идет через GetComp

При этом если мы хотим использовать параметр компса при взаимодействии предмета он может отсутствовать списке доступных свойств. Созданных нами свойств нет так используется самый базовый класс. Что бы получить доступ необходимо в CompMyTestBuilding : ThingComp добавить свойство указывающее на объект свойства компса:
public CompProperties_MyTestBilding Props => (CompProperties_MyTestBilding)props; // приведение свойства к CompProperties_MyTestBilding

Теперь в метод опции строения можно передать параметр копса который будит определять количество наносимого урона указного в файле xml
yield return new FloatMenuOption("Option 1", delegate
{
	selPawn.TakeDamage(new DamageInfo(DamageDefOf.Bite, 
		compMyTestBuilding.Props.Damage));
});



____
____




















GI.CS.RimWorold.Mods
LearningModBuildings.EventMod








 

